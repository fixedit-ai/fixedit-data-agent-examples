# Subscribe to the FixedIT QR Code Decoder and push to HTTP endpoint
#
# This configuration subscribes to detections from the FixedIT QR Code Decoder ACAP
# by setting up a Unix domain socket on which the FixedIT QR Code Decoder
# application can write messages to. These messages are then pushed to an HTTP
# endpoint as a POST request with the JSON payload.
#
# Environment Variables:
# - PUSH_URL: URL to which to send the JSON payload, e.g.
#   "http://my.server.com:8080/api/v1/metrics"
# - READER_SOCKET_PATH: Path on which to create the Unix domain socket (defaults to
#   "/dev/shm/fixedit.qr_code_decoder.sock")
# - INSECURE_SKIP_VERIFY: Skip verification of the HTTPS certificate
#   (defaults to false for security and only matters for HTTPS URLs)
# - Other variables set automatically by the FixedIT Data Agent.

[agent]

  # The interval at which metrics are collected.
  #interval = "${SYNC_INTERVAL_SECONDS}s"
  # Note that this should not matter for this config since the socket reader
  # is a triggered input, not a scheduled input.
  interval = "1s"

  # The interval at which metrics are sent to the output.
  # This can be longer than the collection interval which will cause
  # telegraf to batch metrics together and reduce the number of requests
  # to the server. Setting it too big will consume more memory and
  # increase latency.
  #flush_interval = "${FLUSH_INTERVAL_SECONDS}s"
  # We want to set this to a small value to reduce latency.
  flush_interval = "1s"

  # The debug mode (true/false) which controls the verbosity of Telegraf.
  debug = ${TELEGRAF_DEBUG}

  # Max number of metrics to buffer in memory if they can't be sent to
  # the output. A too low number will result in metrics being lost if the
  # output is not accessible (e.g. loss of network connection). A too large
  # number might fill up the memory during a long outage and will spam the
  # server once the server is back online.
  metric_buffer_limit = 10

# Global tags for device identification
[global_tags]
  # Geo tags set by the user in the FixedIT Data Agent configuration.
  area = "${AREA}"
  geography = "${GEOGRAPHY}"
  region = "${REGION}"
  site = "${SITE}"
  latitude = "${DEVICE_LOCATION_LATITUDE}"
  longitude = "${DEVICE_LOCATION_LONGITUDE}"

  # Type tag set by the user in the FixedIT Data Agent configuration.
  type = "${TYPE}"

  # Device info tags set automatically by the FixedIT Data Agent.
  device_brand = "${DEVICE_PROP_BRAND}"
  device_model = "${DEVICE_PROP_MODEL}"
  device_variant = "${DEVICE_PROP_VARIANT}"
  device_type = "${DEVICE_PROP_TYPE}"
  product_full_name = "${DEVICE_PROP_FULL_NAME}"
  device_serial = "${DEVICE_PROP_SERIAL}"
  firmware_version = "${DEVICE_PROP_FIRMWARE}"
  architecture = "${DEVICE_PROP_ARCH}"
  soc = "${DEVICE_PROP_SOC}"

  # Data agent metadata set automatically by the FixedIT Data Agent.
  data_agent_version = "${APP_VERSION}"
  data_agent_start_time = "${APP_START_TIME}"

# Set up the input that will consume QR code detections.
#
# Example JSON message format (one message per barcode/QR code detected):
# {
#   "level": "INFO",
#   "message": {
#     "code_type": "QR-Code",
#     "decoded_data": "https://fixedit.ai",
#     "frame_timestamp": 1760453555,
#     "image_height": 1080,
#     "image_width": 1920,
#     "log_type": "detection",
#     "norm_height": 0.1388888955116272,
#     "norm_width": 0.07656252384185791,
#     "norm_center_x": 0.5833333134651184,
#     "norm_center_y": 0.41111111640930176,
#     "number_codes_in_frame": 2,
#     "pid": "1805635",
#   },
#   "source": "BarcodeReader"
# }
[[inputs.socket_listener]]
  # Listen on Unix domain socket for barcode detection messages
  service_address = "unix://${READER_SOCKET_PATH:-/dev/shm/fixedit.qr_code_decoder.sock}"

  # Set socket permissions to allow group write access
  # This enables applications running as dynamic user to write to socket
  socket_mode = "0664"

  # Set read timeout. It's a bit unclear what effect this has, but it's probably
  # the max read time for one single message. It's probably good for robustness
  # to set this even though it's unlikely it would trigger when using a unix
  # domain socket.
  read_timeout = "30s"

  # Set the buffer size of the socket. This allows some elasticity in the
  # writing and reading of the socket, but the main buffering is happening
  # in the Telegraf output buffer. This must absolutely not be smaller than
  # the expected maximum size of a message. If we would include e.g. image
  # data in the message, then we should use a larger buffer size.
  # Generally, if it's important to never lose a message, use a large
  # buffer size.
  read_buffer_size = "200KiB"

  # Parse incoming data as JSON
  data_format = "json_v2"

  # Override measurement name for consistency in database
  name_override = "barcode_reader_app"

  # Default tags that will be added to all measurements
  [inputs.socket_listener.tags]
    input_method = "socket"

  [[inputs.socket_listener.json_v2]]
    # Get all fields and top-level tags
    [[inputs.socket_listener.json_v2.object]]
      path = "@this"

      # Mark which values should be used as tags. Note that we need to reference
      # them as if 'disable_prepend_keys' was not set, but the names will be
      # changed before sending them so that e.g. "message_pid" becomes a tag
      # called "pid".
      tags = ["level", "source", "message_pid", "message_log_type"]

      # Disable prepend keys. Since the input is a nested object,
      # we would get "message_" prefix for all fields in the 'message'
      # sub-object. By disabling prepend keys, we keep only the inner
      # keys.
      disable_prepend_keys = true

      # Define field types explicitly to ensure consistent type handling
      # in InfluxDB. This prevents type conflicts when writing metrics.
      # This might not matter for strings, but floats and integers could be
      # parsed differently otherwise and we would get errors when trying to write
      # them to InfluxDB is the type has changed.
      [inputs.socket_listener.json_v2.object.fields]
        source = "string"                      # Source of the message (e.g. app name)
        level = "string"                       # Level of the message (e.g. INFO)
        message_decoded_data = "string"        # The decoded content from the barcode
        message_frame_timestamp = "int"        # Unix timestamp (seconds since epoch)
        message_number_codes_in_frame = "int"  # Total number of codes in the frame
        message_code_type = "string"           # Type of code (e.g. QR-code)
        message_norm_center_x = "float"        # Normalized X coordinate
        message_norm_center_y = "float"        # Normalized Y coordinate
        message_norm_width = "float"           # Normalized width
        message_norm_height = "float"          # Normalized height
        message_image_width = "int"            # Width of the source image in pixels
        message_image_height = "int"           # Height of the source image in pixels
        message_confidence = "float"           # Detection confidence score (optional, 0-1)
        message_log_type = "string"            # Log type (e.g. detection, warning, error)
        message_pid = "string"                 # Process ID of the sender

# Get the device's local IP addresses every 10 seconds.
# This might return multiple IP addresses separated by commas.
[[inputs.exec]]
  command = "sh -c 'hostname -i | tr \" \" \",\"'"
  timeout = "5s"
  data_format = "value"
  data_type = "string"
  name_override = "local_ip_addresses"
  interval = "10s"

# Starlark processor to merge IP addresses into QR code detection metrics
[[processors.starlark]]
namepass = ["local_ip_addresses", "barcode_reader_app"]

  source = '''
state = {
    "ip_addresses": "unknown"
}

def update_ip_addresses(metric):
    state["ip_addresses"] = metric.fields["value"]

def apply(metric):
    if metric.name == "local_ip_addresses":
        update_ip_addresses(metric)
        return None # Dont let the IP address metric through

    # Add the IP addresses as a tag to the barcode detection metric
    ip_addresses = state.get("ip_addresses")
    metric.tags["local_ip_addresses"] = ip_addresses
    return metric # Let the barcode detection metric through
'''

# Set up the HTTP output that will send the JSON payload to the HTTP endpoint.
[[outputs.http]]
  # Only consume messages from the QR Code Decoder input.
  namepass = ["barcode_reader_app"]

  # Set the URL which to make the HTTP request to.
  url = "${PUSH_URL}"

  # Set the HTTP method to use (POST, PUT or PATCH).
  method = "POST"

  # Set the timeout for the HTTP request. After this timeout, the
  # request will be aborted and the message will be queued for a
  # later retry.
  timeout = "10s"

  # Set the data format to use for the HTTP request. When this is set to
  # 'json' the body will be on the format:
  # {"fields": {...}, "name": "...", "tags": {...}, "timestamp": ...}
  data_format = "json"

  # Disable batching - send each metric immediately. This ensures that we
  # get low latency and one request per detected code.
  use_batch_format = false

  # Skip verification of the HTTPS certificate. Set via the INSECURE_SKIP_VERIFY
  # environment variable (defaults to false for security).
  insecure_skip_verify = ${INSECURE_SKIP_VERIFY:-false}

  # Set the headers for the HTTP request.
  [outputs.http.headers]
    Content-Type = "application/json"
    User-Agent = "FixedIT-Data-Agent/${APP_VERSION}"
