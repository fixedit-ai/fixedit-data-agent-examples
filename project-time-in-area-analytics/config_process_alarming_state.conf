# This configuration file sets up a heartbeat metric
# and applies a Starlark processor for inactivity monitoring.
# The Starlark processor checks if there have been any alarming
# detections since the last heartbeat, and if not, sets
# the alarming state to "false". Note that it only monitors
# for alarming state metrics in general, it does not keep
# track of what or how many objects triggered the alarm.

# ---- Heartbeat (1 metric/second) ----
[[inputs.exec]]
  # This is a static heartbeat to trigger the inactivity monitor,
  # so it does not matter what data it includes.
  commands = ["sh -c 'echo heartbeat value=1i'"]
  data_format = "influx"
  interval = "1s"
  name_override = "alarming_state_heartbeat"

# ---- Starlark processor ----
# This gets triggered by both the heartbeat and any alarming state metrics.
# This makes sure the code is run at least once per second even if there
# are no alarming state metrics.
[[processors.starlark]]
  namepass = ["alarming_state_heartbeat", "alerting_frame_two"]
  source = '''
"""
Monitor if an alerting_frame_two metric has not been sent
since the last alarming_state_heartbeat metric.
When we have an alerting object in the monitored zone,
we will get a metric every time we observe that object.
Once the object leaves the area, we stop receiving
alerting_frame_two metrics. This function makes sure that
we send a metric every time we go from no alerting objects
to at least one alerting object, and from at least one
alerting object to no alerting object.
"""
load("logging.star", "log")

"""
We initialize the state to keep it as a persistent
state between calls. We can use it to store information
such as the "has_alarm_since_last_heartbeat" value.
"""
state = {
  # This variable is used to track if an "alerting_frame_two"
  # metric has been received since the last
  # "alarming_state_heartbeat" metric.
  "has_alarm_since_last_heartbeat": False
}

def apply(metric):
    # If we got an alerting frame, update the state to alerting state
    # and return without producing any metric.
    if metric.name == "alerting_frame_two":
        state["has_alarm_since_last_heartbeat"] = True
        return

    # Validate that the metric is a heartbeat
    if metric.name != "alarming_state_heartbeat":
        log.debug("Error: received metric with unexpected name: " + metric.name)
        return

    has_alarm_since_last_heartbeat = state.get("has_alarm_since_last_heartbeat")

    # We want to track if the alarm has been triggered between
    # heartbeats, so we always reset the state to False at
    # each heartbeat so we can start monitoring again.
    state["has_alarm_since_last_heartbeat"] = False

    alarming_state_metric = Metric("alerting_state_metric")
    alarming_state_metric.time = metric.time
    alarming_state_metric.fields["active"] = has_alarm_since_last_heartbeat
    return alarming_state_metric
'''