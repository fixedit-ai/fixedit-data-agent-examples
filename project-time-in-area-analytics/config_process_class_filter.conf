# Class Filter Processor
#
# This processor filters detection frames based on object class/type classification.
# Only detections matching the configured class filter are passed through.
#
# The OBJECT_TYPE_FILTER variable controls which classes pass:
# - ALL: pass only verified detections (object_type != null) - DEFAULT
# - ALL_UNVERIFIED: pass all detections including unverified (object_type == null or any verified class)
# - Specific class name (e.g., "Human"): pass only exact matches (case-insensitive)
#
# If OBJECT_TYPE_FILTER is not set, defaults to ALL and logs a warning.
#
# Input: detection_frame metrics from input processor
# Output: detection_frame_class_filtered metrics (filtered by class)
#
# Environment Variables:
# - OBJECT_TYPE_FILTER: Class filter mode or specific class name (optional)
#   Defaults to ALL if not set.

[[processors.starlark]]
  # Only consume metrics with name "detection_frame"
  namepass = ["detection_frame"]

  # Inline Starlark script for class filtering
  source = '''
load("logging.star", "log")

# Initialize mode and target (will be set during first apply)
state = {}

def init_mode(object_type_str):
    """Initialize filtering mode based on object_type_str parameter.

    Args:
        object_type_str: Filter setting string (ALL, ALL_UNVERIFIED, or specific class name),
                         this is case-insensitive.
    """
    if "mode" in state:
        return  # Already initialized

    object_type_str = object_type_str.lower()

    if object_type_str == "" or object_type_str.startswith("${"):
        log.warn(
          "OBJECT_TYPE_FILTER not set; defaulting to ALL (pass only verified detections). " +
          "If this is intended: set OBJECT_TYPE_FILTER=ALL"
        )
        state["mode"] = "all"
    elif object_type_str == "all" or object_type_str == "all_unverified":
        state["mode"] = object_type_str
    else:
        # Exact class match mode (case-insensitive)
        state["mode"] = "exact"
        state["target"] = object_type_str

def canonicalize_object_type(value):
    """Validate and canonicalize the object_type field value.

    Converts to lowercase for case-insensitive comparison and normalizes
    non-string/missing values to None to represent unverified objects.

    Returns canonical_value: None for unclassified, or lowercase class name string.
    """
    if value == None:
        # None represents unclassified/unverified object
        return None
    # Check if value is a string
    if type(value) != type(""):
        log.warn("object_type not a string: " + str(value) + "; treating as unverified")
        return None
    if value == "":
        log.warn("object_type empty string; treating as unverified")
        return None
    # Normalize to lowercase for case-insensitive comparison
    return value.lower()


def should_keep(mode, obj):
    """Determine if a detection should pass the filter.

    Args:
        mode: Filter mode (all, all_unverified, or exact)
        obj: Canonical object_type (None for unverified, or lowercase class name)

    Returns: True if detection should pass, False if it should be filtered out
    """
    if mode == "all":
        # Pass only verified detections
        return obj != None
    elif mode == "all_unverified":
        # Pass all detections
        return True
    else:
        # exact mode: match target class
        target = state.get("target")
        return obj == target


def apply(metric):
    """Filter detection_frame metrics by object class type.

    Renames passing metrics to detection_frame_class_filtered.
    Returns None to drop metrics that don't match the filter.
    """
    # Initialize mode based on the environment variable
    init_mode(filter_env_var)
    mode = state["mode"]

    # Get and canonicalize the object_type field
    obj = canonicalize_object_type(metric.fields.get("object_type"))

    track_id = metric.fields.get("track_id", "unknown")

    # Determine if this detection should pass the filter
    obj_str = obj if obj else "None"
    mode_str = "exact:" + state.get("target") if mode == "exact" else mode
    if should_keep(mode, obj):
        log.debug("apply: track_id=" + track_id + " object_type=" + obj_str + " mode=" + mode_str + " - PASS")
        filtered = deepcopy(metric)
        filtered.name = "detection_frame_class_filtered"
        return filtered
    else:
        log.debug("apply: track_id=" + track_id + " object_type=" + obj_str + " mode=" + mode_str + " - FILTER OUT")
        return None
'''

  [processors.starlark.constants]
    filter_env_var = "${OBJECT_TYPE_FILTER}"